# python的内存管理

python内存管理可以从三个方面讲：垃圾回收、引用计数、内存池机制



## 垃圾回收

垃圾回收的意思就是，在python语言内部，当一个对象的引用计数为0时，它将被垃圾收集机制处理掉。



## 引用计数

python依靠引用计数方式追踪内存中的对象，python内部记录着对象的引用次数，当引用计数归零的时候表示对象不再需要，即被垃圾回收。



## 内存池机制

python将不用的内存放进内存池而不是返回给操作系统。

- Pymalloc机制：为了对小块内存的申请和释放，加速Python的执行效率
- Python中小于256个字节的对象都是依靠pymalloc分配器来实现的，而稍大的对象用的则是系统的malloc。
- 对于Python对象，如整数、浮点数和List这些，都有自己独立的内存池，对象间并不共享他们的内存池。换句话说就是，假设你分配并且释放了大量的整数，那么用于缓存这些整数的内存就不能再分配给浮点数。



# is和==的区别

is：同一性运算符；==：比较操作符



== 用来比较两个值是否相等，is比较的是两个对象的id是否相等。

```python
>>> x = y = [4,5,6]
>>> z = [4,5,6]
>>> x == y
True
>>> x == z
True
>>> x is y
True
>>> x is z
False
>>> print id(x)
3075326572
>>> print id(y)
3075326572
>>> print id(z)
3075328140
```





# 深拷贝和浅拷贝的区别

深浅拷贝也是赋值的一种，python中赋值的特点如下：

1. 赋值是将一个对象的地址赋值给一个变量，让变量指向该地址。
2. 修改不可变对象（str、tuple）需要开辟新的空间
3. 修改可变对象（list等）不需要开辟新的空间



## 深拷贝

深拷贝就是对对象的资源的拷贝（完全拷贝了一个副本，容器内部元素地址都不一样）

```python
>>> from copy import deepcopy
>>> a=[1,2,3]
>>> b=deepcopy(a)
>>> id(a)
55645000
>>> id(b)
58338824
>>> a.append(4)
>>> 
>>> print(a)
[1, 2, 3, 4]
>>> print(b)
[1, 2, 3]
```

这里可以看出，深拷贝后，a和b的地址以及a和b中的元素地址均不同，这是完全拷贝的一个副本，修改a后，发现b没有发生任何改变，因为b是一个完全的副本，元素地址与a均不同，a修改不影响b。

> 深拷贝是在另一块地址中创建一个新的变量或容器，同时容器内的元素的地址也是新开辟的，仅仅是值相同而已，是完全的副本。也就是说。



## 浅拷贝

浅拷贝就是对引用的拷贝（仅仅复制了容器中元素的地址）

```python
>>> a=['hello',[1,2,3]]
>>> b=a[:]
>>> [id(x) for x in a]
[55792504, 6444104]
>>> [id(x) for x in b]
[55792504, 6444104]
>>> a[0]='world'
>>> a[1].append(4)
>>> print(a)
['world', [1, 2, 3, 4]]
>>> print(b)
['hello', [1, 2, 3, 4]]
```

未修改前，a和b中元素的地址都是相同的，不可变的 hello 和可变的 list 地址都一样，说明浅拷贝只是将容器内的元素的地址复制了一份。这可以通过修改后，b中字符串没改变，但是list元素随着a相应改变得到验证。

> 浅拷贝是在另一块地址中创建一个新的变量或容器，但是容器内的元素的地址均是源对象的元素的地址的拷贝。也就是说新的容器中指向了旧的元素。





# 全局解释器锁GIL

全局解释器锁(GIL)在CPython中，当解释器执行任何python代码时，都需要先获得这把锁，遇到I/O操作时会释放这把锁。所以同一时间只会有一个线程获得这把锁在运行，其他线程都处于等待GIL释放的状态。

> 这也就直接导致了CPython不能利用物理多核加速运算。



这样设计的原因是早期多核CPU还不存在，GIL搞定多线程安全在当时是最简单的设计。但是硬件发展太快，如今多核CPU已经很普遍了。如今python3中依旧保留有GIL。



那么python想要利用多核CPU，一个简单的方式是使用多进程，python提供的multiprocessing可以实现这个功能，但是多进程相互通信比多线程更麻烦，或者将需要使用多核的代码改用其他语言例如C、C++来实现并封装为python扩展。



更好的方式是使用ctypes，他可以让python调用任何c动态库导出的函数，它会在调用c函数前释放GIL。



# 使用二分法查找某个数

二分法又叫折半查找，要求待查找的列表是有序的，特点速度快，平均性能好。首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。

```python
def Search(number_list, target):
  n = len(number_list)
  start, end = 0, n-1
  while start <= end:
    # 取中间索引
    mid = (start + end) // 2
    # 中间值等于目标
    if number_list[mid] == target:
      return True
    # 中间值大于目标，取前半段
    elif number_list[mid] >= target:
      end = mid - 1
    # 中间值小于目标，取后半段
    else:
      start = mid + 1
  return False
```

